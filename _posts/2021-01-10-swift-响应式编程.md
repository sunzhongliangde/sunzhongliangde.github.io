---
layout:     post
title:      swift-响应式编程
subtitle:   
date:       2021-01-10
author:     sunzhongliang
header-img: img/post-bg-github-cup.jpg
catalog: true
tags:
    - swift
---


## 响应式编程
`响应式编程`(Reactive Programming)，简称`RP`；也是一种编程范式，可以简化异步编程，提供更优雅的数据绑定。<br>
比较著名成熟的框架有两个

1. ReactiveCocoa<br>
官网: [https://reactivecocoa.io/](https://reactivecocoa.io/) <br>
github: [https://github.com/ReactiveCocoa/ReactiveCocoa/](https://github.com/ReactiveCocoa/ReactiveCocoa/)
2. ReactiveX<br>
官网: [http://reactivex.io/](http://reactivex.io/) <br>
github: [https://github.com/ReactiveX/RxSwift](https://github.com/ReactiveX/RxSwift)

#### RxSwift
`RxSwift`(reactive for swift), ReactiveX的swift版本<br>
源码：[https://github.com/ReactiveX/RxSwift](https://github.com/ReactiveX/RxSwift) <br>
中文文档：[https://beeth0ven.github.io/RxSwift-Chinese-Documentation/](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/) <br>
<br>
**RxSwift的核心角色**<br>
- Observable 负责发送事件(Event)
- Observer 负责订阅Observable，监听Observable发送的事件(Event)

`RxSwift`源码(Event.swift)关于`Event`描述如下
```swift
/// Represents a sequence event.
///
/// Sequence grammar: 
/// **next\* (error | completed)**
public enum Event<Element> {
    /// Next element is produced.
    case next(Element)

    /// Sequence terminated with an error.
    case error(Swift.Error)

    /// Sequence completed successfully.
    case completed
}

```
所以，`Event`有3种
1. `next`: 携带具体的数据
2. `error`: 携带错误信息，表明Observable终止，不会再发出事件
3. `completed`: 表明Observable终止，不会再发出事件

<br>

**创建Observable**<br>
```swift
override func viewDidLoad() {
    super.viewDidLoad()
    
    // 发消息
    let observable = Observable<Int>.create { (observer) -> Disposable in
        observer.onNext(123)  // 发送了123消息
        return Disposables.create()
    }
    // 也可以采用这种方式发送订阅消息，代表只发送一个1，然后就结束
    // Observable.just(1)

    // 这种方式代表发送三次，分别是1、2、3，然后结束
    // Observable.from([1,2,3])
    
    // 订阅
    observable.subscribe { (event) in
        switch event {
        case .next(let element):
            print("element:", element)
        case .error(let error):
            print("error:", error)
        case .completed:
            print("completed")
        }
    }
    // 第二种订阅方式
    observable.subscribe { (element) in
        
    } onError: { (error) in
        
    } onCompleted: {
        
    } onDisposed: {
        
    }
}
```
比如我们在做控件开发的时候，需要将一个定时器的的值显示在`label`上面：
```swift
// 代表两秒之后，每隔一秒执行一次
let observable = Observable<Int>.timer(.seconds(2), period: .seconds(1), scheduler: MainScheduler.instance)

// 绑定到控件上面
observable.map{"text:\($0)"}.bind(to: label.rx.text)
```
<br>

**Disposables**<br>
每当`Observable`被订阅的时候都会返回一个`Observable`的实例，调用`Observable`的`dispose`就相当于取消订阅
```swift
// 代表两秒之后，每隔一秒执行一次
let observable = Observable<Int>.timer(.seconds(2), period: .seconds(1), scheduler: MainScheduler.instance)

// 绑定到控件上面
let observer = observable.map{"text:\($0)"}.bind(to: label.rx.text)
observer.dispose()
```
对于取消订阅，有以下几种方式<br>
1. 立即取消订阅
    ```swift
    // 订阅方法之后紧跟着dispose方法取消订阅
    observable.subscribe { (event) in
        print(event)
    }.dispose()
    ```
2. 当bag(被控制器或者其他对象持有)销毁(deinit)时，会自动调用Disposables实例的dispose
    ```swift
    let bag = DisposeBag();
    observable.subscribe { (event) in
        print(event)
    }.disposed(by: bag)
    ```
3. 代表这一个订阅会跟随控制器的生命周期
    ```swift
    observable.takeUntil(self.rx.deallocated).map{"\($0)"}.bind(to: label.rx.text)
    ```

> 本文首次发布于 [孙忠良 Blog](https://sunzhongliangde.github.io), 作者 [@sunzhongliang] ,
转载请保留原文链接.
